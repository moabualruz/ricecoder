use std::{collections::HashMap, path::Path};

use serde::{Deserialize, Serialize};
use tokio::process::Command;

/// Vulnerability scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityScanResult {
    pub vulnerabilities: Vec<Vulnerability>,
    pub scan_duration: std::time::Duration,
    pub scan_timestamp: chrono::DateTime<chrono::Utc>,
}

/// Individual vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub package: String,
    pub version: String,
    pub severity: VulnerabilitySeverity,
    pub description: String,
    pub advisory_url: Option<String>,
    pub cvss_score: Option<f64>,
}

/// Vulnerability severity levels
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum VulnerabilitySeverity {
    Low,
    Medium,
    High,
    Critical,
}

/// License scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicenseScanResult {
    pub licenses: HashMap<String, Vec<String>>,
    pub incompatible_licenses: Vec<String>,
    pub scan_timestamp: chrono::DateTime<chrono::Utc>,
}

/// Code security scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeSecurityScanResult {
    pub issues: Vec<SecurityIssue>,
    pub files_scanned: usize,
    pub scan_duration: std::time::Duration,
}

/// Security issue found in code
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityIssue {
    pub file: String,
    pub line: usize,
    pub column: usize,
    pub severity: VulnerabilitySeverity,
    pub rule: String,
    pub description: String,
    pub code_snippet: String,
}

/// Configuration security scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConfigSecurityScanResult {
    pub issues: Vec<ConfigSecurityIssue>,
    pub files_scanned: usize,
}

/// Configuration security issue
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConfigSecurityIssue {
    pub file: String,
    pub issue_type: ConfigIssueType,
    pub description: String,
    pub recommendation: String,
}

/// Types of configuration security issues
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConfigIssueType {
    WeakPermissions,
    ExposedSecrets,
    InsecureDefaults,
    MissingSecurityHeaders,
    WeakEncryption,
}

/// Vulnerability scanner trait
#[async_trait::async_trait]
pub trait VulnerabilityScanner: Send + Sync {
    /// Scan dependencies for vulnerabilities
    async fn scan_dependencies(
        &self,
        manifest_path: &Path,
    ) -> anyhow::Result<VulnerabilityScanResult>;

    /// Scan code for security issues
    async fn scan_code(&self, source_path: &Path) -> anyhow::Result<CodeSecurityScanResult>;

    /// Scan configuration files for security issues
    async fn scan_config(&self, config_path: &Path) -> anyhow::Result<ConfigSecurityScanResult>;

    /// Scan licenses for compatibility
    async fn scan_licenses(&self, manifest_path: &Path) -> anyhow::Result<LicenseScanResult>;
}

/// Default vulnerability scanner implementation
pub struct DefaultVulnerabilityScanner;

impl DefaultVulnerabilityScanner {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait::async_trait]
impl VulnerabilityScanner for DefaultVulnerabilityScanner {
    async fn scan_dependencies(
        &self,
        manifest_path: &Path,
    ) -> anyhow::Result<VulnerabilityScanResult> {
        let start_time = std::time::Instant::now();

        // Run cargo audit
        let output = Command::new("cargo")
            .args(&["audit", "--json"])
            .current_dir(manifest_path.parent().unwrap_or(Path::new(".")))
            .output()
            .await?;

        let scan_duration = start_time.elapsed();

        let vulnerabilities = if output.status.success() {
            // Parse cargo audit JSON output
            let audit_output: serde_json::Value = serde_json::from_slice(&output.stdout)?;
            self.parse_cargo_audit_output(&audit_output)?
        } else {
            // Parse error output for vulnerabilities
            self.parse_cargo_audit_error(&String::from_utf8_lossy(&output.stderr))?
        };

        Ok(VulnerabilityScanResult {
            vulnerabilities,
            scan_duration,
            scan_timestamp: chrono::Utc::now(),
        })
    }

    async fn scan_code(&self, source_path: &Path) -> anyhow::Result<CodeSecurityScanResult> {
        let start_time = std::time::Instant::now();

        let mut issues = Vec::new();
        let mut files_scanned = 0;

        // Walk through source files
        for entry in walkdir::WalkDir::new(source_path)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
        {
            let path = entry.path();
            if let Some(ext) = path.extension() {
                if matches!(
                    ext.to_str(),
                    Some("rs") | Some("js") | Some("ts") | Some("py")
                ) {
                    files_scanned += 1;
                    let file_issues = self.scan_file_for_security_issues(path).await?;
                    issues.extend(file_issues);
                }
            }
        }

        Ok(CodeSecurityScanResult {
            issues,
            files_scanned,
            scan_duration: start_time.elapsed(),
        })
    }

    async fn scan_config(&self, config_path: &Path) -> anyhow::Result<ConfigSecurityScanResult> {
        let mut issues = Vec::new();
        let mut files_scanned = 0;

        // Walk through config files
        for entry in walkdir::WalkDir::new(config_path)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
        {
            let path = entry.path();
            if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                if file_name.contains("config")
                    || file_name.contains("settings")
                    || matches!(
                        path.extension().and_then(|e| e.to_str()),
                        Some("yaml") | Some("yml") | Some("toml") | Some("json")
                    )
                {
                    files_scanned += 1;
                    let file_issues = self.scan_config_file_for_issues(path).await?;
                    issues.extend(file_issues);
                }
            }
        }

        Ok(ConfigSecurityScanResult {
            issues,
            files_scanned,
        })
    }

    async fn scan_licenses(&self, manifest_path: &Path) -> anyhow::Result<LicenseScanResult> {
        // Run cargo license check
        let output = Command::new("cargo")
            .args(&["license", "--json"])
            .current_dir(manifest_path.parent().unwrap_or(Path::new(".")))
            .output()
            .await?;

        let licenses = if output.status.success() {
            self.parse_cargo_license_output(&String::from_utf8_lossy(&output.stdout))?
        } else {
            HashMap::new()
        };

        // Check for incompatible licenses
        let allowed_licenses = ["MIT", "Apache-2.0", "BSD-2-Clause", "BSD-3-Clause", "ISC"];
        let mut incompatible_licenses = Vec::new();

        for (package, package_licenses) in &licenses {
            for license in package_licenses {
                if !allowed_licenses.contains(&license.as_str()) {
                    incompatible_licenses.push(format!("{}: {}", package, license));
                }
            }
        }

        Ok(LicenseScanResult {
            licenses,
            incompatible_licenses,
            scan_timestamp: chrono::Utc::now(),
        })
    }
}

impl DefaultVulnerabilityScanner {
    fn parse_cargo_audit_output(
        &self,
        _audit_output: &serde_json::Value,
    ) -> anyhow::Result<Vec<Vulnerability>> {
        // In a real implementation, parse the actual cargo audit JSON output
        // For now, return empty vector
        Ok(Vec::new())
    }

    fn parse_cargo_audit_error(&self, error_output: &str) -> anyhow::Result<Vec<Vulnerability>> {
        let mut vulnerabilities = Vec::new();

        // Parse error output for vulnerability information
        for line in error_output.lines() {
            if line.contains("vulnerability") || line.contains("advisory") {
                // Extract vulnerability info from error line
                // This is a simplified parser - real implementation would be more robust
                vulnerabilities.push(Vulnerability {
                    id: "unknown".to_string(),
                    package: "unknown".to_string(),
                    version: "unknown".to_string(),
                    severity: VulnerabilitySeverity::Medium,
                    description: line.to_string(),
                    advisory_url: None,
                    cvss_score: None,
                });
            }
        }

        Ok(vulnerabilities)
    }

    async fn scan_file_for_security_issues(
        &self,
        file_path: &Path,
    ) -> anyhow::Result<Vec<SecurityIssue>> {
        let content = tokio::fs::read_to_string(file_path).await?;
        let mut issues = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            // Check for hardcoded secrets
            if line.contains("password") || line.contains("secret") || line.contains("key") {
                if self.looks_like_hardcoded_secret(line) {
                    issues.push(SecurityIssue {
                        file: file_path.display().to_string(),
                        line: line_num + 1,
                        column: line.find("password").unwrap_or(0) + 1,
                        severity: VulnerabilitySeverity::High,
                        rule: "hardcoded-secret".to_string(),
                        description: "Potential hardcoded secret detected".to_string(),
                        code_snippet: line.trim().to_string(),
                    });
                }
            }

            // Check for unsafe code usage
            if line.contains("unsafe") {
                issues.push(SecurityIssue {
                    file: file_path.display().to_string(),
                    line: line_num + 1,
                    column: line.find("unsafe").unwrap_or(0) + 1,
                    severity: VulnerabilitySeverity::Medium,
                    rule: "unsafe-code".to_string(),
                    description: "Unsafe code usage detected".to_string(),
                    code_snippet: line.trim().to_string(),
                });
            }

            // Check for SQL injection patterns
            if line.contains("SELECT") || line.contains("INSERT") || line.contains("UPDATE") {
                if line.contains("+") || line.contains("format!") {
                    issues.push(SecurityIssue {
                        file: file_path.display().to_string(),
                        line: line_num + 1,
                        column: 1,
                        severity: VulnerabilitySeverity::High,
                        rule: "sql-injection".to_string(),
                        description: "Potential SQL injection vulnerability".to_string(),
                        code_snippet: line.trim().to_string(),
                    });
                }
            }
        }

        Ok(issues)
    }

    fn looks_like_hardcoded_secret(&self, line: &str) -> bool {
        // Simple heuristic: check if line contains quotes and looks like a value assignment
        let line = line.trim();
        (line.contains("=\"") || line.contains("='"))
            && !line.contains("env::")
            && !line.contains("std::env")
            && !line.contains("var(")
    }

    async fn scan_config_file_for_issues(
        &self,
        file_path: &Path,
    ) -> anyhow::Result<Vec<ConfigSecurityIssue>> {
        let content = tokio::fs::read_to_string(file_path).await?;
        let mut issues = Vec::new();

        // Check for exposed secrets in config
        for line in content.lines() {
            if line.contains("password") || line.contains("secret") || line.contains("key") {
                if line.contains("123456") || line.contains("password") || line.contains("admin") {
                    issues.push(ConfigSecurityIssue {
                        file: file_path.display().to_string(),
                        issue_type: ConfigIssueType::ExposedSecrets,
                        description: "Potential exposed secret in configuration".to_string(),
                        recommendation: "Use environment variables or secure key management"
                            .to_string(),
                    });
                }
            }
        }

        // Check file permissions (this would require additional system calls in real implementation)
        // For now, just add a placeholder check
        if file_path.to_string_lossy().contains("config") {
            issues.push(ConfigSecurityIssue {
                file: file_path.display().to_string(),
                issue_type: ConfigIssueType::WeakPermissions,
                description: "Config file permissions should be restrictive".to_string(),
                recommendation: "Set config files to 600 permissions".to_string(),
            });
        }

        Ok(issues)
    }

    fn parse_cargo_license_output(
        &self,
        license_output: &str,
    ) -> anyhow::Result<HashMap<String, Vec<String>>> {
        let mut licenses = HashMap::new();

        // Parse cargo license JSON output
        if let Ok(json) = serde_json::from_str::<serde_json::Value>(license_output) {
            if let Some(packages) = json.get("packages").and_then(|p| p.as_array()) {
                for package in packages {
                    if let (Some(name), Some(license)) = (
                        package.get("name").and_then(|n| n.as_str()),
                        package.get("license").and_then(|l| l.as_str()),
                    ) {
                        licenses
                            .entry(name.to_string())
                            .or_insert_with(Vec::new)
                            .push(license.to_string());
                    }
                }
            }
        }

        Ok(licenses)
    }
}
